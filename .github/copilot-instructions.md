# Effect AWS - AI Coding Agent Instructions

## Architecture Overview

This is a monorepo providing **Effect-based wrappers** for AWS SDK v3 clients. The project bridges AWS services with the [Effect](https://www.effect.website/) ecosystem, enabling type-safe, composable AWS operations with built-in error handling.

**Key Components:**
- **`packages/client-*`**: Auto-generated Effect wrappers for 50+ AWS SDK v3 clients (S3, DynamoDB, Lambda, etc.)
- **`packages/commons`**: Shared utilities for all clients - `Service.ts` (command execution), `ServiceLogger.ts`, error handling
- **`packages/{dynamodb,s3,lambda,etc.}`**: Higher-level helper libraries built on top of clients
- **`scripts/`**: Code generation tooling that reads AWS SDK specs and generates Effect services
- **`projenrc/`**: Projen configuration for managing monorepo structure

## Critical Workflows

### Building & Testing
```bash
pnpm install           # Install dependencies (requires pnpm@9.x)
pnpm build             # Build all packages
pnpm test              # Run tests across all packages
pnpm watch             # Watch mode for development
```

### Code Generation (Adding New AWS Clients)
**IMPORTANT**: Most client packages are auto-generated. Follow this exact process:

1. Add service to `scripts/client-singularities.ts` with `description` and `commandToTest`
2. Update name normalization in `scripts/utils.ts` if needed (e.g., `apigatewayv2` â†’ `api-gateway-v2`)
3. Run `pnpm default` - regenerates project structure via Projen
4. Run `pnpm codegen-client` - interactive CLI to generate service code
5. Run `pnpm eslint --fix` - format generated code
6. Commit changes

**Never manually edit** files in `packages/client-*/src/` - they'll be overwritten.

### Project Structure Changes
This project uses **Projen** for infrastructure-as-code project management:
- Edit `.projenrc.ts` to add packages, dependencies, or configuration
- Run `pnpm default` (alias for `pnpm exec projen`) to synthesize changes
- Files with headers `~~ Generated by projen` are managed - don't edit directly

## Effect-Specific Patterns

### Service Layer Pattern
All AWS clients follow this architecture (see `packages/client-s3/src/S3Service.ts`):

```typescript
// 1. Service interface with Effect-wrapped methods
interface S3Service$ {
  getObject(args, options?): Effect.Effect<Output, Errors>
}

// 2. Service factory using Effect.gen
const makeS3Service = Effect.gen(function*() {
  const client = yield* S3ClientInstance
  return yield* Service.fromCommandsAndServiceFn(commands, ...)
})

// 3. Effect.Tag for dependency injection
export class S3Service extends Effect.Tag("@effect-aws/client-s3/S3Service")<S3Service, S3Service$>() {
  static readonly defaultLayer = Layer.effect(this, makeS3Service)
  static readonly layer = (config) => ...
  static readonly baseLayer = (evaluate) => ...
}
```

Usage:
```typescript
import { S3 } from "@effect-aws/client-s3"
import { Effect } from "effect"

// With defaultLayer
const program = S3.getObject({ Bucket: "test", Key: "file" })
Effect.provide(program, S3.defaultLayer)

// With custom config
Effect.provide(program, S3.layer({ region: "us-west-2", logger: true }))
```

### Error Handling
All services use tagged errors (see `packages/commons/src/Service.ts`):
```typescript
// Errors are automatically tagged from AWS ServiceException
Effect.catchTag("NoSuchKeyError", (error) => ...)
Effect.catchTags({
  NoSuchKeyError: () => ...,
  SdkError: () => ...
})
```

### Testing Pattern
Tests use `aws-sdk-client-mock` with Effect's `runPromiseExit` (see `packages/client-sns/test/SNS.test.ts`):

```typescript
import { mockClient } from "aws-sdk-client-mock"
import { SNS } from "@effect-aws/client-sns"
import { Effect, Exit } from "effect"

const clientMock = mockClient(SNSClient)
clientMock.on(PublishCommand).resolves({})

const result = await Effect.runPromiseExit(
  SNS.publish(args).pipe(Effect.provide(SNS.defaultLayer))
)
expect(result).toEqual(Exit.succeed({}))
```

## Package Conventions

### Workspace Dependencies
- Use `workspaceDeps: [commons]` in `.projenrc.ts` for internal dependencies
- Use `workspacePeerDeps: [clientPackage]` for helper packages (e.g., `dynamodb` depends on `client-dynamodb`)
- `peerDeps` for Effect packages use range `"effect@>=3.15.5 <4.0.0"`

### File Structure (Client Packages)
```
packages/client-{service}/
  src/
    {Service}Service.ts      # Main service implementation (auto-generated)
    {Service}ServiceConfig.ts # Service configuration layer
    {Service}ClientInstance.ts # AWS SDK client instance layer
    Errors.ts                 # Tagged error types (auto-generated)
    index.ts                  # Public exports
  test/
    {Service}.test.ts         # Service tests
```

### File Structure (Helper Packages)
```
packages/{helper}/
  src/
    index.ts                  # Public API
  examples/ (optional)
    handler.ts                # Usage examples for Lambda, Tracer, etc.
```

## Integration Points

### Custom HTTP Handlers
`packages/http-handler` provides Effect-based HTTP request handling via `@effect/platform`. Services check for `HttpHandler.RequestHandler` in context and inject it into AWS SDK middleware (see `Service.ts:95-98`).

### AWS Powertools Integration
- `powertools-logger`: Wraps AWS Lambda Powertools Logger with Effect
- `powertools-tracer`: Wraps AWS Lambda Powertools Tracer with Effect + X-Ray

### Lambda Handlers
`packages/lambda` provides `makeLambda(handler, layer?)` to convert Effect handlers to AWS Lambda handlers with graceful shutdown support.

## Documentation

- API docs generated via `@effect/docgen` - run `pnpm docgen`
- Website built with VitePress in `pages/` - `pnpm pages:dev`
- Each package has its own README with usage examples

## Common Pitfalls

1. **Don't edit generated files** - anything in `client-*/src/` is regenerated
2. **Always run `pnpm default` after `.projenrc.ts` changes** - Projen must synthesize
3. **Use Effect.gen syntax** for async operations - avoid mixing Promises
4. **Provide layers correctly** - `Effect.provide(program, layer)` not the reverse
5. **Test with mockClient** - never use real AWS credentials in tests
